<?php

namespace Obfuscator;

use Contracts\PHXContract;

/**
 * @author Amamr Faizi <ammarfaizi2@gmail.com>
 * @version 0.0.1
 * @license MIT
 * @since 0.0.1
 */
class Obfuscator implements PHXContract
{
	
	/**
	 * @var string
	 */
	private $file;

	/**
	 * @var string
	 */
	private $to;

	/**
	 * @var string
	 */
	private $key;

	/**
	 * @var res
	 */
	private $h;

	/**
	 * @var bool
	 */
	public $cli = false;

	/**
	 * @var array
	 */
	private $functions = [];

	/**
	 * @param string $file
	 * @param string $to
	 * @param string $key
	 * @return void
	 */
	public function __construct($file, $to, $key)
	{
		$this->file = $file;
		$this->to   = $to;
		$this->key  = $key;
	}

	/**
	 * @return void
	 */
	private function open()
	{
		$this->h = fopen($this->to, "w");
		flock($this->h, LOCK_EX);
		$this->cli and fwrite($this->h, "#!/usr/bin/env php\n");
		fwrite($this->h, "<?php\n");
	}

	private function init()
	{
		fwrite($this->h, 

"
/**
 * DO NOT EDIT THIS FILE BY HAND!
 *
 * Ice Tea PHP Obfuscator.
 *
 * @license MIT
 * @version 0.0.1
 * @link https://github.com/ammarfaizi2/afx
 *
 * bb:".chr(0).":".chr(1).":".chr(2).":".chr(3).":".chr(4).":".chr(5)."
 * 
 * get:".sha1($this->key)."
 */

#include <php/phx.h>
#include <icetea/obfuscator.h>
#define STATE_HASH ".($this->stateHash = rand(1, 10000))."
#define PHP_ENGINE_CODE 1771

"

		);
		$this->functions = [
			"base64_decode" => $this->genName(4096),
			"gzinflate" => $this->genName(4096),
			"sha1" => $this->genName(rand(10, 20)),
			"file_get_contents" => $this->genName(rand(10, 20)),
			"trim" => $this->genName(rand(10, 20)),
			"substr" => $this->genName(rand(10, 20)),
			"explode" => $this->genName(rand(10, 20)),
			"rand" => $this->genName(rand(10, 20)),
			"sleep" => $this->genName(rand(10, 20))
		];
		$c = count($this->functions) - 1;
		$i = 0;
		foreach ($this->functions as $k => $v) {
			fwrite(
				$this->h,
				"\${$v}=\"".
				$this->convert($k).
				"\"XOR".($i++===$c?" ":"")
			);
		}
	}

	/**
	 * @param string $str
	 * @return string
	 */
	private function chrToHex($str)
	{
		return "\\x".dechex(ord($str));
	}

	/**
	 * @param string $str
	 * @return string
	 */
	private function chrToOct($str)
	{
		return "\\".decoct(ord($str));
	}

	/**
	 * @param string $str
	 * @return string
	 */
	private function convert($str)
	{
		$r = "";
		foreach (str_split($str) as $char) {
			$r .= rand(2, 3) % 2 ? $this->chrToOct($char) : $this->chrToHex($char);
		}
		return $r;
	}

	private function generateKey()
	{
		self::saltGenerator();
	}

	private function run()
	{
		$decryptor = $this->genName(20);
		$key = self::saltGenerator(10);
		$key2 = $this->genName(10);
		$me = $this->genName(10);
		$o = $this->genName(10);
		$segmentSeparation = $this->genName(64);
		$file = trim(shell_exec("/usr/bin/env php -w ".$this->file));
		$this->hashKey = $this->genName(20);
		$segmentKey = $this->genName(20);
		$file = 
			"eval(".
			"{$decryptor}(".
			"\${$this->functions['gzinflate']}(\"".
			$this->escape(gzdeflate(self::encrypt("?>".$file, $this->key, false))).
			"\"),{$decryptor}(\${$segmentKey},\"".
			$this->escape($segmentSeparation)
			."\",!1),!2));";
		$file =
			"error_reporting(0x0);\${$segmentKey} = \"".$this->escape($this->genName(10))."\";".
			"\${$this->functions['sha1']}(".
			"\${$this->functions['substr']}(".
			"\${$me}=".
			"\${$this->functions['file_get_contents']}(".
			"\${$this->functions['explode']}(".
			"\"".$this->convert("(")."\", __FILE__)[0x0]), 0x00,".
			"\${$o}))===(".
			"{$decryptor}(".
			"\${$this->functions['trim']}(".
			"\${$this->functions['explode']}(".
			"{$decryptor}(\"".
			$this->escape(self::encrypt("@@@@@@", $key, false))."\",".
			"\"".$this->escape($key)."\",!0xac),".
			"\${$this->functions['substr']}(".
			"\${$me},".
			"\${$o}))[0x0]), \"{$this->hashKey}\", !0xff))?0x7ccf^0x00ddc^(int)(\${$segmentKey}=\"".
			$this->escape(self::encrypt($this->key, $segmentSeparation, false)).
			"\") : (".
			"\${$this->functions['sleep']}(".
			"\${$this->functions['rand']}(0x1,0x3)) xor eval(".
			"\${$this->functions['gzinflate']}(\"".
			$this->escape(gzdeflate("/**".$this->genName(10)."\n".$this->genName(15)."\t".$this->genName(40)."*/")).
			"\")) xor exit(".
			"{$decryptor}(\"".
			$this->escape(self::encrypt("\n\nSegmentation fault (core dumped)\n", $segmentKey, false)).
			"\", \"".$this->escape($segmentKey)."\",!!!0xbc1)));".
			$file;
		$file = 
			"eval(".
			"\${$this->functions['gzinflate']}(".
			"\${$this->functions['base64_decode']}(".
			$decryptor."(\"".
			$this->escape(self::encrypt(base64_encode(gzdeflate($file)), $key, false)).
			"\", \"{$key}\", !0x71f))));";
		$file = 
			"eval(".
			"\${$this->functions['gzinflate']}(".
			"\${$this->functions['base64_decode']}(".
			$decryptor."(\"".
			$this->escape(self::encrypt(base64_encode(gzdeflate($file)), $key2, false)).
			"\", \"{$key2}\", !0xee))));";
		$file = "\${$o}=__COMPILER_HALT_OFFSET__;eval(".
			"\${$this->functions['gzinflate']}(\"".
			$this->escape(gzdeflate($this->generateDecryptor($decryptor))).
			"\")/*".$this->genName(3)."*/"."./*".$this->genName(3)."*/".
			"\${$this->functions['gzinflate']}(".
			"\${$this->functions['gzinflate']}(\"".
			$this->escape(gzdeflate(gzdeflate($file))).
			"\"))) OR @".$this->genName(2048).";\"".$this->escape($this->genName(1024))."\";".
			"__halt_compiler();";


		fwrite($this->h, $file);	
	}

	private function generateDecryptor($decryptorName)
	{
		$var = [
			"string" => "\$".$this->genName(rand(10, 20)),
			"key" => "\$".$this->genName(rand(10, 20)),
			"binary" => "\$".$this->genName(rand(10, 20)),
			"slen" => "\$".$this->genName(rand(10, 20)),
			"salt" => "\$".$this->genName(rand(10, 20)),
			"klen" => "\$".$this->genName(rand(10, 20)),
			"new" => "\$".$this->genName(rand(10, 20)),
			"r" => "\$".$this->genName(rand(10, 20)),
			"cost" => "\$".$this->genName(rand(10, 20)),
			"i" => "\$".$this->genName(rand(10, 20)),
			"j" => "\$".$this->genName(rand(10, 20)),
			"k" => "\$".$this->genName(rand(10, 20))
		];
		return 'function '.$decryptorName.'('.$var["string"].', '.$var["key"].', '.$var["binary"].' = true) { if ('.$var["binary"].') { '.$var["string"].' = base64_decode(strrev('.$var["string"].')); } '.$var["slen"].' = strlen('.$var["string"].'); '.$var["salt"].' = substr('.$var["string"].', '.$var["slen"].' - 5); '.$var["string"].' = substr('.$var["string"].', 0, ('.$var["slen"].' = '.$var["slen"].' - 5)); '.$var["klen"].' = strlen('.$var["key"].'); '.$var["new"].' = '.$var["r"].' = ""; '.$var["cost"].' = 1; for('.$var["i"].'='.$var["j"].'=0;'.$var["i"].'<'.$var["klen"].';'.$var["i"].'++) { '.$var["new"].' .= chr(ord('.$var["key"].'['.$var["i"].']) ^ ord('.$var["salt"].'['.$var["j"].'++])); if ('.$var["j"].' === 5) { '.$var["j"].' = 0; } } '.$var["new"].' = sha1('.$var["new"].'); for('.$var["i"].'='.$var["j"].'='.$var["k"].'=0;'.$var["i"].'<'.$var["slen"].';'.$var["i"].'++) { '.$var["r"].' .= chr( ord('.$var["string"].'['.$var["i"].']) ^ ord('.$var["new"].'['.$var["j"].'++]) ^ ord('.$var["salt"].'['.$var["k"].'++]) ^ ('.$var["i"].' << '.$var["j"].') ^ ('.$var["k"].' >> '.$var["j"].') ^ ('.$var["slen"].' % '.$var["cost"].') ^ ('.$var["cost"].' >> '.$var["j"].') ^ ('.$var["cost"].' >> '.$var["i"].') ^ ('.$var["cost"].' >> '.$var["k"].') ^ ('.$var["cost"].' ^ ('.$var["slen"].' % ('.$var["i"].' + '.$var["j"].' + '.$var["k"].' + 1))) ^ (('.$var["cost"].' << '.$var["i"].') % 2) ^ (('.$var["cost"].' << '.$var["j"].') % 2) ^ (('.$var["cost"].' << '.$var["k"].') % 2) ^ (('.$var["cost"].' * ('.$var["i"].'+'.$var["j"].'+'.$var["k"].')) % 3) ); '.$var["cost"].'++; if ('.$var["j"].' === '.$var["klen"].') { '.$var["j"].' = 0; } if ('.$var["k"].' === 5) { '.$var["k"].' = 0; } } return '.$var["r"].'; }';
	}

	private function escape($string)
	{
		return str_replace(
			["\\", "\"", "\$"],
			["\\\\", "\\\"", "\\\$"],
			$string
		);
	}

	/**
	 * @param string $string
	 * @param string $key
	 * @param bool	 $binarySafe
	 * @return string
	 */
	private static function encrypt($string, $key, $binarySafe = true)
	{
		$slen = strlen($string);
		$klen = strlen($key);
		$r = $newKey = "";
		$salt = self::saltGenerator();
		$cost = 1;
		for($i=$j=0;$i<$klen;$i++) {
			$newKey .= chr(ord($key[$i]) ^ ord($salt[$j++]));
			if ($j === 5) {
				$j = 0;
			}
		}
		$newKey = sha1($newKey);
		for($i=$j=$k=0;$i<$slen;$i++) {		
			$r .= chr(
				ord($string[$i]) ^ ord($newKey[$j++]) ^ ord($salt[$k++]) ^ ($i << $j) ^ ($k >> $j) ^
				($slen % $cost) ^ ($cost >> $j) ^ ($cost >> $i) ^ ($cost >> $k) ^
				($cost ^ ($slen % ($i + $j + $k + 1))) ^ (($cost << $i) % 2) ^ (($cost << $j) % 2) ^ 
				(($cost << $k) % 2) ^ (($cost * ($i+$j+$k)) % 3)
			);
			$cost++;
			if ($j === $klen) {
				$j = 0;
			}
			if ($k === 5) {
				$k = 0;
			}
		}
		$r .= $salt;
		if ($binarySafe) {
			return strrev(base64_encode($r));
		} else {
			return $r;
		}
	}

	/**
	 * @param string $string
	 * @param string $key
	 * @param bool	 $binarySafe
	 * @return string
	 */
	private static function decrypt($string, $key, $binarySafe = true)
	{
		if ($binarySafe) {
			$string = base64_decode(strrev($string));
		}
		$slen = strlen($string);
		$salt = substr($string, $slen - 5);
		$string = substr($string, 0, ($slen = $slen - 5));
		$klen = strlen($key);
		$newKey = $r = "";
		$cost = 1;
		for($i=$j=0;$i<$klen;$i++) {
			$newKey .= chr(ord($key[$i]) ^ ord($salt[$j++]));
			if ($j === 5) {
				$j = 0;
			}
		}
		$newKey = sha1($newKey);
		for($i=$j=$k=0;$i<$slen;$i++) {
			$r .= chr(
				ord($string[$i]) ^ ord($newKey[$j++]) ^ ord($salt[$k++]) ^ ($i << $j) ^ ($k >> $j) ^
				($slen % $cost) ^ ($cost >> $j) ^ ($cost >> $i) ^ ($cost >> $k) ^
				($cost ^ ($slen % ($i + $j + $k + 1))) ^ (($cost << $i) % 2) ^ (($cost << $j) % 2) ^ 
				(($cost << $k) % 2) ^ (($cost * ($i+$j+$k)) % 3)
			);
			$cost++;
			if ($j === $klen) {
				$j = 0;
			}
			if ($k === 5) {
				$k = 0;
			}
		}
		return $r;
	}

	/**
	 * @param int $n
	 * @return string
	 */
	private static function saltGenerator($n = 5)
	{
		$s = range(chr(1), chr(0x7f));
		$r = ""; $c=count($s)-1;
		for($i=0;$i<$n;$i++) {
			$r.= $s[rand(0, $c)];
		}
		return $r;
	}

	/**
	 * @return void
	 */
	private function close()
	{
		fflush($this->h);
		fclose($this->h);
		$salt = $this->genName(3);
		file_put_contents(
			$this->to,
			self::encrypt($hash = sha1(file_get_contents($this->to)), $this->hashKey, false).
			"@@@@@@.debug�\157\x2e\163\x68\x73\x74\x72\164\x61\x62\x2e\151\156\x74\x65\x72\160\x2e\156\157\164\145\56\101\x42\111\55\164\141\x67\56\x6e\x6f\164\145\x2e\x67\156\x75\x2e\142\165\x69\154\144\x2d\x69\x64\56\x67\156\x75\x2e\x68\141\x73\x68\56\x64\171\x6e\163\171\x6d\56\144\171\x6e\x73\x74\x72\56\147\x6e\165\56\166\145\x72\x73\x69\157\156\x2e\147\x6e\165\56\x76\x65\x72\163\151\157\156\x5f\162\x2e\162\145\154\x61\56\x64\x79\x6e\56\162\145\x6c\x61\x2e\x70\154\164\56\x69\x6e\x69\x74\x2e\x70\x6c\x74\56\x67\157\164\56\164\145\170\164\56\146\x69\156\x69\56\x72\x6f\x64\141\x74\x61\56\x65\x68\x5f\146\x72\141\155\x65\x5f\150\144\x72\x2e\145\x68\137\146\x72\141\155\x65\x2e\151\x6e\151\164\x5f\141\x72\x72\141\x79\x2e\x66\x69\x6e\x69\x5f\141\162\x72\x61\x79\56\x64\141\x74\141\56\162\145\x6c\x2e\x72\157\56\x64\x79\x6e\x61\155\x69\x63\x2e\x64\x61\x74\141\56\x62\163\x73\x2e\147\156\165\x5f\x64\145\142\x75\147\154\x69\x6e\153/$".sha1($this->key.$salt)."$/".$salt."$/\n\n".self::saltGenerator(200),
			FILE_APPEND | LOCK_EX
		);
		fprintf(STDOUT, "Obfuscation finished!\n\n");
		fprintf(STDOUT, "Input file\t: ".realpath($this->file)."\n");
		fprintf(STDOUT, "Output file\t: ".realpath($this->to)."\n");
		fprintf(STDOUT, "Key file\t: ".$this->key."\n");
		fprintf(STDOUT, "LC Hash \t: ".$hash."\n");
		exit(0);
	}

	/**
	 * @return void
	 */
	public function obfuscate()
	{
		$this->open();
		$this->init();
		$this->run();
		$this->close();
	}

	/**
	 * @return string
	 */
	private function genName($n=32, $noExtendedAscii = false)
	{
		$r = "";
		$a = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_";
		if (! $noExtendedAscii) {
			for ($i=0; $i < 5; $i++) { 
				for ($i=135; $i < 255; $i++) { 
					$a .= chr($i);
				}
			}
		}
		$c = strlen($a) - 1;
		$r.= $a[rand(0, $c)];
		if ($n === 1) {
			return $r;
		}
		$a.= "1234567890";
		$c = strlen($a) - 1;
		$n--;
		for ($i=0; $i < $n; $i++) { 
			$r.= $a[rand(0, $c)];
		}
		return $r;
	}

	public static function usage()
	{
		fprintf(STDERR, "Ice Tea PHP Obfuscator 0.0.1\n\n");
		fprintf(STDERR, "Usage: obftea [options] file...\n");
		fprintf(STDERR, "\t-h, --help\t\t\tDisplay this information.\n");
		fprintf(STDERR, "\t-k <key>, --ket=<key> \t\tSpecify a file key.\n");
		fprintf(STDERR, "\t-o <file>, --output=<file> \tPlace the output into <file>.\n");
		fprintf(STDERR, "\n\nBug report: https://github.com/ammarfaizi2/afx\n\n");
	}
}
