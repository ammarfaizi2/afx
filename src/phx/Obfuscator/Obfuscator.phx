<?php

namespace Obfuscator;

/**
 * @author Amamr Faizi <ammarfaizi2@gmail.com>
 * @version 0.0.1
 * @license MIT
 * @since 0.0.1
 */
class Obfuscator
{
	
	/**
	 * @var string
	 */
	private $file;

	/**
	 * @var string
	 */
	private $to;

	/**
	 * @var string
	 */
	private $key;

	/**
	 * @var res
	 */
	private $h;

	/**
	 * @var array
	 */
	private $functions = [];

	/**
	 * @param string $file
	 * @param string $to
	 * @param string $key
	 * @return void
	 */
	public function __construct($file, $to, $key)
	{
		$this->file = $file;
		$this->to   = $to;
		$this->key  = $key;
	}

	/**
	 * @return void
	 */
	private function open()
	{
		$this->h = fopen($this->to, "w");
		flock($this->h, LOCK_EX);
		fwrite($this->h, "<?php ");
	}

	private function init()
	{
		$this->functions = [
			"base64_decode" => $this->genName(400),
			"gzinflate" => $this->genName(400)
		];
		$c = count($this->functions) - 1;
		$i = 0;
		foreach ($this->functions as $k => $v) {
			fwrite(
				$this->h,
				"\${$v}=\"".
				$this->convert($k).
				"\"XOR".($i++===$c?" ":"")
			);
		}
	}

	/**
	 * @param string $str
	 * @return string
	 */
	private function chrToHex($str)
	{
		return "\\x".dechex(ord($str));
	}

	/**
	 * @param string $str
	 * @return string
	 */
	private function chrToOct($str)
	{
		return "\\".decoct(ord($str));
	}

	/**
	 * @param string $str
	 * @return string
	 */
	private function convert($str)
	{
		$r = "";
		foreach (str_split($str) as $char) {
			$r .= rand(2, 3) % 2 ? $this->chrToOct($char) : $this->chrToHex($char);
		}
		return $r;
	}

	private function run()
	{
		$file = "?>".file_get_contents($this->file);
		fwrite(
			$this->h,
			"eval(".
			"\${$this->functions['gzinflate']}(".
			"\${$this->functions['base64_decode']}(".
			"\${$this->functions['gzinflate']}(\"".
			gzdeflate(base64_encode(gzdeflate($file))).
			"\"))));"
		);
	}

	/**
	 * @param string $string
	 * @param string $key
	 * @param bool	 $binarySafe
	 * @return string
	 */
	private static function encrypt($string, $key, $binarySafe = true)
	{
		$slen = strlen($string);
		$klen = strlen($key);
		$r = $newKey = "";
		$salt = self::saltGenerator();
		$cost = 1;
		for($i=$j=0;$i<$klen;$i++) {
			$newKey .= chr(ord($key[$i]) ^ ord($salt[$j++]));
			if ($j === 5) {
				$j = 0;
			}
		}
		$newKey = sha1($newKey);
		for($i=$j=$k=0;$i<$slen;$i++) {		
			$r .= chr(
				ord($string[$i]) ^ ord($newKey[$j++]) ^ ord($salt[$k++]) ^ ($i << $j) ^ ($k >> $j) ^
				($slen % $cost) ^ ($cost >> $j) ^ ($cost >> $i) ^ ($cost >> $k) ^
				($cost ^ ($slen % ($i + $j + $k + 1))) ^ (($cost << $i) % 2) ^ (($cost << $j) % 2) ^ 
				(($cost << $k) % 2) ^ (($cost * ($i+$j+$k)) % 3)
			);
			$cost++;
			if ($j === $klen) {
				$j = 0;
			}
			if ($k === 5) {
				$k = 0;
			}
		}
		$r .= $salt;
		if ($binarySafe) {
			return strrev(base64_encode($r));
		} else {
			return $r;
		}
	}

	/**
	 * @param string $string
	 * @param string $key
	 * @param bool	 $binarySafe
	 * @return string
	 */
	private static function decrypt($string, $key, $binarySafe = true)
	{
		if ($binarySafe) {
			$string = base64_decode(strrev($string));
		}
		$slen = strlen($string);
		$salt = substr($string, $slen - 5);
		$string = substr($string, 0, ($slen = $slen - 5));
		$klen = strlen($key);
		$newKey = $r = "";
		$cost = 1;
		for($i=$j=0;$i<$klen;$i++) {
			$newKey .= chr(ord($key[$i]) ^ ord($salt[$j++]));
			if ($j === 5) {
				$j = 0;
			}
		}
		$newKey = sha1($newKey);
		for($i=$j=$k=0;$i<$slen;$i++) {
			$r .= chr(
				ord($string[$i]) ^ ord($newKey[$j++]) ^ ord($salt[$k++]) ^ ($i << $j) ^ ($k >> $j) ^
				($slen % $cost) ^ ($cost >> $j) ^ ($cost >> $i) ^ ($cost >> $k) ^
				($cost ^ ($slen % ($i + $j + $k + 1))) ^ (($cost << $i) % 2) ^ (($cost << $j) % 2) ^ 
				(($cost << $k) % 2) ^ (($cost * ($i+$j+$k)) % 3)
			);
			$cost++;
			if ($j === $klen) {
				$j = 0;
			}
			if ($k === 5) {
				$k = 0;
			}
		}
		return $r;
	}

	/**
	 * @param int $n
	 * @return string
	 */
	private static function saltGenerator($n = 5)
	{
		$s = range(chr(1), chr(0x7f));
		$r = ""; $c=count($s)-1;
		for($i=0;$i<$n;$i++) {
			$r.= $s[rand(0, $c)];
		}
		return $r;
	}

	/**
	 * @return void
	 */
	private function close()
	{
		$var = [
			"key1" => [
				$this->genName(32),
				str_replace(
					["\"", "\$"], 
					["\\\"", "\\\$"], 
					self::encrypt(
						$this->key, 
						"icetea_obfuscator123qwe", 
						false
					)
				)
			]
		];
		fclose($this->h);
	}

	/**
	 * @return void
	 */
	public function obfuscate()
	{
		$this->open();
		$this->init();
		$this->run();
		$this->close();
	}

	/**
	 * @return string
	 */
	private function genName($n=32, $noExtendedAscii = false)
	{
		$r = "";
		$a = "qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM_";
		if (! $noExtendedAscii) {
			for ($i=0; $i < 5; $i++) { 
				for ($i=135; $i < 255; $i++) { 
					$a .= chr($i);
				}
			}
		}
		$c = strlen($a) - 1;
		$r.= $a[rand(0, $c)];
		if ($n === 1) {
			return $r;
		}
		$a.= "1234567890";
		$c = strlen($a) - 1;
		$n--;
		for ($i=0; $i < $n; $i++) { 
			$r.= $a[rand(0, $c)];
		}
		return $r;
	}
}
